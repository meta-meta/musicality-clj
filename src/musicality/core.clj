(ns musicality.core
  (:gen-class)) ; https://github.com/bbatsov/clojure-style-guide#prefer-require-over-use

;;;; Musicality Live-compose

;;; The idea is to distill musical ideas and rearrange them on the fly. To decompose and recompose. To refactor music.
;;; The notes on a staff are a publication. They are output. They are instructions, removed from the ideas behind the notes.

;;; Representing Pitch Classes

;; One approach would assign ૪ and Ɛ to 10 and 11. this would allow numbers to directly represent pitch-class.
;;#_(def ૪ 10) ; invalid number
#_(def Ɛ 11) ; this one is fine


;; Rather than try to solve this with a different char or something, use keywords.


;; We can order these, but to simply define them, I think it's more formal/precise to define as a set.


;; This gives us the order, but it is not isomorphic to the thing we're trying to represent. :0 should technically follow :Ɛ because the shape of the pitch-class-space makes it so. We could operate on the pitch-classes indirectly via mod12 int arithmetic. To do so, we'd have to convert pc->int and then int->pc




#_(pc->int :Ɛ)
#_(map pc->int pitch-class-order)



#_(map int->pc (range 24))

;; Rotate up a P5 or down P4 using modulo arithmetic
#_(map #(int->pc (+ 7 (pc->int %))) [:0 :4 :7 :Ɛ])
#_(map #(int->pc (+ -5 (pc->int %))) [:0 :4 :7 :Ɛ])

;; Or we could define an infinite cycle

#_(take 36 pitch-class-cycle-up)


#_(take 36 pitch-class-cycle-dn)


#_(map #(pitch-class-rotate % 7) [:0 :4 :7 :Ɛ])
#_(map #(pitch-class-rotate % -5) [:0 :4 :7 :Ɛ])


#_(pitch-class-rotate-all [:0 :4 :7 :Ɛ] 7)
;; TODO: should this be legal? seems convenient.
#_(pitch-class-rotate-all [:0 :4 :7 :Ɛ] :7)

;; What about unordered?
#_(map #(pitch-class-rotate % 7) #{:0 :4 :7 :Ɛ})
;; Nope, it returns a list. To maintain a set, gotta reduce
#_(reduce (fn [a b] (conj a (pitch-class-rotate b 7))) #{} #{:0 :4 :7 :Ɛ})
;; TODO: handle this in pitch-class-rotate-all


(comment "Terms
* beat: a collection of events scheduled to fire at some subdivision of a measure.
* sub-beat: a collection of events scheduled to fire at some subdivision of a beat
* event: could be a MIDI event or a fn (or an osc message to be sent to a max synthesizer?)
* measure: a collection of beats (and sub-beats) that is looped by the sequencer


TODO: beat vs pulse vs tick vs meter vs measure

"

         ;; A pitch-class-set has no order. It should be treated thusly. It doesn't make sense for it to be added to a beat or sequence or anything other than another pc-set. It is abstract. It needs something to draw out actual pitches out from it. It needs something to give it order if used for a melody.
         (def some-pc-set  #{:0 :4 :7 :Ɛ})

         ;; A pitch-class-vector has order but no pitches.
         (def some-pc-vec [:0 :4 :7 :Ɛ])

         ;; There are all kinds of ways to turn pitch-class collections into pitch things that can be played like chords and melodies. Using normal form calculation could be helpful in choosing chord voicings. Given a pc-set, you want to be able to talk about the chord voicings by assigning some role to each member of the set. For a triad, you'll have a root, a third and a fifth. It might be unambiguous to calculate which is which depending on the spacing between pcs. Normal form should provide a general solution.

         ;; once roles are sorted out, voicings can be generated by talking about how each role should be represented. see forte numbers: https://en.wikipedia.org/wiki/List_of_pitch-class_sets -- is there any language built around these? using the index of the normal form, the triads work out to root: 0 third: 1 fifth: 2. yes, seems unambiguous to use the normal-form-index to refer to roles.

         ;; a voicing mask could be defined to place roles in octaves
         (defn pc-set->chord "applies a voicing-mask to pc-set to generate a set of pitches"
           [pc-set voicing-mask] #{})

         ;; given #{:0 :4 :7}
         ;; normal-form [0 4 7]    
         (pc-set->chord some-pc-set
                        {:root-octave 4                      ; :0 -> 60
                         0 #{0 -1 1}                         ; 0 refers to 0th index of normal-form: 0 -> 60 48 72
                         1 #{0}                              ; 1 = index 1 of normal-form: 4 ->  64
                         2 #{0 -1}                           ; 2 = index 2 of normal-form: 7 -> 67 49
                         })
         ;; we get the pich-set #{48 49 60 64 67 72} 

         ;; maybe cleaner:
         {0 #{3 4 5}                         ; 0 refers to 0th index of normal-form: 0 -> 60 48 72
          1 #{4}                             ; 1 = index 1 of normal-form: 4 -> 64
          2 #{3 4}                           ; 2 = index 2 of normal-form: 7 -> 67 49
          }


         ;; given  #{:0 :4 :7 :Ɛ}
         ;; normal form [0 1 5 8]


         [60 64 67 71] ; start with note vector 


         (let [some-notes  [60 64 67]
               as-chord (chord some-notes) ; 
               ])

         (+ 00 01 10) ; this can be nice

         ;; TODO instead of vectors
         (def some-measure [{:fn {2 {:fn1 ["arg1" "arg2" "arg3"]}}
                             :note {0 [60 127 65 120] 10 [20 55]}
                             :cc {0 [1 65] 1 [1 79] 2 [1 0]}}
                            {}
                            {}
                            {}]))




;; TODO: rename



#_(with-vel 64 [0 1 2])
#_(->> [0 1 2]
       (with-vel 64))

;; TODO: rename


#_(chord 62 [0 1 2])
#_(->> [60 64 67 71]
       (chord 22))





#_(rotate-seq 1 [0 1 2 3])
#_(->> [0 1 2 3]
       (rotate-seq 1))

;; TODO prob not necessary. use take and cycle
(defn repeat-flat [n coll] (flatten (repeat n coll)))

#_(repeat-flat 5 [1 2])
#_(take 10 (cycle [1 2]))
#_(->> [1 2]
       (repeat-flat 5))
#_(->> [1 2]
     (cycle)
     (take 10))



#_(map-if-num #(+ % %) [0 1 2 :r 3 [] 4])
#_(->> [0 3 [] :r 4 4]
       (map-if-num #(* % 2)))






(comment "some new sequences 2020-07-24"

         (->> (merge-seqs

               (->> [0 4 6 :r :r 6 10 12 :r :r :r 15 10 5]
                    (map-if-num #(+ 31 %))
                    (with-vel 30))

               (->> [0 1 2 [] 1 0 [] [] -2 [] -2 -2]
                    (map-if-num (fn [t] (chord 10 (->> [0 4 7 11] (map #(+ 60 t %))))))))

              (send-seq :note))

         (clear)

         (defn chord-mask)

         (->> (merge-seqs
               (let [c1 (->> [0 4 7 11 14] (map #(+ % 42)) (chord 20))
                     c2 (->> [0 4 7 10 16 -5] (map #(+ % 58)) (chord 15))]
                 [c1 [] [] [] [] [] [] []
                  [] c1 [] [] [] [] [] []
                  c2 [] [] [] [] [] [] []
                  [] c1 [] [] [] [] [] []])

               (->> [[] 0 2 3 0 7 0 12 -10 -10 17 [] [] [] 22 [] [] 27]
                    (map-if-num #(+ 60 %))
                    (with-vel 25))

               #_(->> [0 :r 0
                       :r 0 0
                       :r 0 :r
                       0 :r 0]
                      (repeat-flat 4)
                      (map-if-num (fn [n] (+ 29)))
                      (with-vel 10)
                      (rotate-seq 1))

               (->> [0 :r 0
                     :r 0 0
                     :r 0 :r
                     0 :r 0]
                    (repeat-flat 2)
                    (map-if-num (fn [n] (+ 21)))
                    (with-vel 10)
                    (rotate-seq 5))

               (->> [0 :r 0
                     :r 0 0
                     :r 0 :r
                     0 :r 0]
                    (repeat-flat 1)
                    (map-if-num (fn [n] (+ 27)))
                    (with-vel 10)
                    (rotate-seq 6))

               (->> (range 32) (map (fn [n] [22 10]))))
              (send-seq :note))
         (clear)



         ;; TODO: send sub-beats

         (def jazz-ride [0 :r :r 0 :r 0])

         (->> (merge-seqs
               (->> (cycle [:r :r 0 :r :r :r 0 :r])
                    (take 32)
                    (map-if-num #(+ % 62))
                    (with-vel 10))

               (->> (cycle [0 0 :r :r])
                    (take 32)
                    (map-if-num #(+ % 55))
                    (rotate-seq 0)
                    (with-vel 10))

               

               (repeat 32 [])
               )
              (send-seq :note))


         



         (->> (merge-seqs
               
               (with-vel 10
                 [6 :r :r
                  6 :r 6
                  6 :r :r
                  6 :r 6]) ; jazz ride
               
               (with-vel 10
                 (rotate-seq 0
                             [02 :r 02
                              :r 02 02
                              :r 02 :r
                              02 :r 02])) ; bembe wheel

               (with-vel 10 (take 12 (cycle [0 :r :r])))

              (with-vel 4
                 (rotate-seq 0 [1 1 1 :r 1 1 1 :r 1 1 1 :r])) ; snare ostenato
               )

              (send-seq :note))


         (clear)


         (let [a (->> (merge-seqs

                       (->> [[:Ɛ :3 :6] [] [] [] [] []
                             [:Ɛ :5 :6] [] [] [] [] []
                             [:1 :6 :8] [] [] [] [] []
                             [:3 :5 :6] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[] [:૪] [:1] [:8] [] [:5]
                             [] [:1] [] [] [] []
                             [] [:1] [:૪] [:3] [] [:1]
                             [] [:૪] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )
               b (->> (merge-seqs

                       (->> [[:Ɛ :3 :6] [] [] [] [] []
                             [:1 :3 :6] [] [] [] [] []
                             [:3 :5 :6] [] [] [] [] []
                             [] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[:8] [] [] [] [] []
                             [] [] [:3] [] [:૪] []
                             [:8] [] [] [] [] []
                             [:1] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )

               c1 (->> (merge-seqs

                       (->> [[:Ɛ :6] [] [] [] [] []
                             [:1 :3] [] [] [] [] []
                             [:૪ :3] [] [] [] [] []
                             [:1 :6] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[] [] [] [] [] []
                             [] [] [] [] [] []
                             [] [] [] [] [] []
                             [] [] [:1] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )
               c2 (->> (merge-seqs

                       (->> [[:Ɛ :6] [] [] [] [] []
                             [:1 :3] [] [] [] [] []
                             [:3 :7 :૪] [] [] [] [] []
                             [] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[] [] [] [] [] []
                             [] [] [] [] [] []
                             [] [] [] [] [] []
                             [] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )
               d (->> (merge-seqs

                       (->> [[:Ɛ :8 :4] [] [] [] [] []
                             [] [] [] [] [] []
                             [:3 :7 :૪] [] [] [] [] []
                             [] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[:3] [:1] [:3] [:1] [:3] []
                             [:3] [] [:3] [:1] [:3] [:Ɛ]
                             [:0] [:2] [:3] [:5] [:7] [:9]
                             [:૪] [:2] [:7] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )
               e (->> (merge-seqs

                       (->> [[:6 :8 :૪] [] [] [] [] []
                             [:5 :8 :૪] [] [] [] [] []
                             [:3 :8 :૪] [] [] [] [] []
                             [:3 :7 :૪] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 60) c)))
                            (map #(chord 20 %))
                            )

                       (->> [[:7] [:3] [] [:૪] [] [:6]
                             [:7] [] [] [:3] [] []
                             [:3] [] [] [] [] []
                             [] [] [] [] [] []]
                            (map (fn [c] (map #(+ (pc->int %) 72) c)))
                            (map #(chord 20 %))
                            )
                       
                       )
                      )

               
               seq [a a b c1 b c2 d e a c2]
               ]

           
           (swap! fns assoc :fn1-state 0)

           (swap! fns assoc :fn1 #(do
                                    
                                    (clear)
                                    (let [idx (:fn1-state @fns)]
                                      (if (= idx (count seq))
                                        (clear)
                                        (do
                                          (send-seq :note (nth seq (:fn1-state @fns)))
                                          (swap! fns assoc :fn1-state
                                                 (mod (+ 1 (:fn1-state @fns))
                                                      (count seq)))
                                          (send-beat 24 1 :fn :fn1)
                                          )))
                                    
                                    ))           
           )

         ((:fn1 @fns))

         (clear)

         ;; alternate between two seqs by scheduling fns
         (let [seqA (->> (merge-seqs
        
                          (with-vel 10
                            [6 :r :r
                             6 :r 6
                             6 :r :r
                             6 :r 6]) ; jazz ride
        
        
                          (with-vel 10 (take 12 (cycle [0 :r :r])))
        
                          (with-vel 4
                            (rotate-seq 0 [1 1 1 :r 1 1 1 :r 1 1 1 :r])) ; snare ostenato
                          ))
        
               seqB (->> (merge-seqs
        
                          (with-vel 10
                            (rotate-seq 0
                                        [02 :r 02
                                         :r 02 02
                                         :r 02 :r
                                         02 :r 02])) ; bembe wheel
        
                          (with-vel 10 (take 12 (cycle [0 :r :r])))
        
                          (with-vel 4
                            (rotate-seq 0 [1 1 1 :r 1 1 1 :r 1 1 1 :r])) ; snare ostenato
                          ))]
        
           (swap! fns assoc :fn1 #(do
                                    (clear)
                                    (send-seq :note seqB)
                                    (send-beat 12 1 :fn :fn2)))
           (swap! fns assoc :fn2 #(do
                                    (clear)
                                    (send-seq :note seqA)
                                    (send-beat 12 1 :fn :fn1)))
        
           ((:fn1 @fns)))

         (defn bin->rhy [n vel bin-seq]
           (->> bin-seq
                (map #(if (= 0 %) [] n))
                (with-vel vel)))

         (clear)
         (send-seq :note 
                   (merge-seqs
                    
                    (->> [0 1 1 1 0 0 1 1 1 0 0 0]
                         (repeat-flat 4) ; TODO: repeat to fill length n 
                         (bin->rhy 2 60))
                    
                    (->> [1 0 0 0 0 1 0 0 0 0 0 0]
                         (repeat-flat 8)
                         (bin->rhy 0 60))
                    ))


         (clear)
         (send-seq (merge-seqs
                    
                    (->> [0 1 1 1 0 0 1 1 1 0 0 0]
                         (repeat-flat 4) ; TODO: repeat to fill length n 
                         (bin->rhy 2 60))
                    
                    (->> [1 0 0 0 0 1 0 0 0 0 0 0]
                         (repeat-flat 8)
                         (bin->rhy 0 60))
                    )) ; play at 64/16, 16BPI

;         [013568૪7_7_6767_7__]
;

         )







(dir musicality.core)



