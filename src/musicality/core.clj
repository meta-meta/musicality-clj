(ns musicality.core
  (:gen-class)) ; https://github.com/bbatsov/clojure-style-guide#prefer-require-over-use

; Start OSC TODO: musicality.live-compose has dep injection to send/receive OSC
; TODO: could midi sync directly via https://github.com/overtone/midi-clj instead of using Max
(use 'overtone.osc)
(def client (osc-client "localhost" 8000))
(def server (osc-server 9000))

(comment "Terms
* beat: a collection of events to be added to the measure.
* event: could be a MIDI event or a fn
* measure: a collection of beats the is looped by the sequencer

"

; # Representing Pitch Classes
; one approach would assign ૪ and Ɛ to 10 and 11. this would allow numbers to directly represent pitch-class.
         ;; (def ૪ 10) ; invalid number
         ;; (def Ɛ 11) ; this one is fine
; rather than try to solve this with a different char or something, use keywords.
         (def pitch-classes #{:0 :1 :2 :3 :4 :5 :6 :7 :8 :9 :૪ :Ɛ}) ; TODO (annoying that :0 is not highlighted with clojure-keyword-face)
; https://stackoverflow.com/questions/39192226/create-a-keyword-from-a-number  - maybe not highlighting because it's in a grey area

; we can order these, but to simply define them, I think it's more formal/precise to define as a set.
         (def pitch-class-order [:0 :1 :2 :3 :4 :5 :6 :7 :8 :9 :૪ :Ɛ])

; this gives us the order, but it it not isomorphic to the thing we're trying to represent.
; :0 should technically follow :Ɛ because the shape of the pitch-class-space makes it so.
; we could operate on the pitch-classes indirectly via mod12 int arithmetic.
; to do so, we'd have to convert pc->int and then int->pc
         (def pc->int (zipmap pitch-class-order (range)))
         ;; (pc->int :Ɛ)
         ;; (map pc->int pitch-class-order)
         (defn int->pc [x] (nth pitch-class-order (mod x (count pitch-class-order)) x))
         ;; (map int->pc (range 24))

; rotate up a P5 or down P4
         ;; (map #(int->pc (+ 7 (pc->int %))) [:0 :4 :7 :Ɛ])
         ;; (map #(int->pc (+ -5 (pc->int %))) [:0 :4 :7 :Ɛ])

; or we could define an infinite cycle
         (def pitch-class-cycle-up (cycle pitch-class-order))
         ;; (take 36 pitch-class-cycle-up)
         (def pitch-class-cycle-dn (drop 11 (cycle (reverse pitch-class-order)))) ; drop 11 to start on 0
         ;; (take 36 pitch-class-cycle-dn)
         (defn pitch-class-rotate "rotates x in pitch-class-space by rot"
           [x rot]
           (first (drop (Math/abs rot)
                        (drop-while #(not (= x %))
                                    (if  (pos? rot)
                                      pitch-class-cycle-up
                                      pitch-class-cycle-dn)))))
         ;; (map #(pitch-class-rotate % 7) [:0 :4 :7 :Ɛ])
         ;; (map #(pitch-class-rotate % -5) [:0 :4 :7 :Ɛ])
; what about unordered?
         ;; (map #(pitch-class-rotate % 7) #{:0 :4 :7 :Ɛ})
; nope to maintain a set, gotta reduce
         ;; (reduce (fn [a b] (conj a (pitch-class-rotate b 7))) #{} #{:0 :4 :7 :Ɛ})

; a pitch-class-set has no order. it should be treated thusly. it doesn't make sense for it to be added to a beat or sequence or anything. it is abstract. it needs something to draw actual pitches out of it. it needs something to give it order if used for a melody.
         (def some-pc-set  #{:0 :4 :7 :Ɛ})

; a pitch-class-vector has order but no pitches
         (def some-pc-vec [:0 :4 :7 :Ɛ])

; there are all kinds of ways to turn pitch-class collections into pitch things that can be played like chords and melodies. using normal form calculation could be helpful in choosing chord voicings. given a pc-set, you want to be able to talk about the chord voicings by assigning some role to each member of the set. for a triad, you'll have a root, a third and a fifth. it might be obvious to calculate which is which depending on the spacing between pcs. normal form should provide a general solution.

; once roles are sorted out, voicings can be generated by talking about how each role should be represented. see forte numbers: https://en.wikipedia.org/wiki/List_of_pitch-class_sets -- is there any language built around these? using the index of the normal form, the triads work out to root: 0 third: 1 fifth: 2. yes, seems unambiguous to use the normal-form-index to refer to roles.

; a voicing mask could be defined to place roles in octaves
         (defn pc-set->chord "applies a voicing-mask to pc-set to generate a set of pitches" [pc-set voicing-mask] #{})

; given #{:0 :4 :7}
; normal-form [0 4 7]    
         (pc-set->chord some-pc-set
                        {:root-octave 4                      ; :0 -> 60
                         0 #{0 -1 1}                         ; 0 refers to 0th index of normal-form: 0 -> 60 48 72
                         1 #{0}                              ; 1 = index 1 of normal-form: 4 ->  64
                         2 #{0 -1}                           ; 2 = index 2 of normal-form: 7 -> 67 49
                         })
; we get the pich-set #{48 49 60 64 67 72} 

; maybe cleaner:
         {0 #{3 4 5}                         ; 0 refers to 0th index of normal-form: 0 -> 60 48 72
          1 #{4}                              ; 1 = index 1 of normal-form: 4 ->  64
          2 #{3 4}                           ; 2 = index 2 of normal-form: 7 -> 67 49
          }


; given  #{:0 :4 :7 :Ɛ}
; normal form [0 1 5 8]


         [60 64 67 71] ; start with note vector 

; 


         (let [some-notes  [60 64 67]
               as-chord (chord some-notes) ; 
               ])

; 


; TODO instead of vectors


         (def some-measure [{:fns #{[:fn1 "arg1" "arg2" "arg3"]}
                             :midi {0 [60 127 65 120] 10 [20 55]}}
                            {}
                            {}
                            {}]))

(defn send-beat [beat data]
  "sends a beat of data to the max sequencer. beat is 1-based; data is pairs of note vel or fn fn-name"
  (apply (partial osc-send client "/midiSeq")
         (map #(if (number? %) (int %) %) (cons beat data))))

(defn clear-beat [beat] (send-beat beat []))

(doall (map clear-beat (range 1 33)))

(defn with-vel
  "pairs notes with vel. if note is not a number, it is replaced with empty []. vel defaults to 64"
  ([ns vel]
   (map (fn [n] (if (number? n) [n vel] [])) ns))
  ([ns] (with-vel ns 64)))

(defn chord
  "pairs notes with vel"
  ([ns vel] (flatten (with-vel ns vel)))
  ([ns] (chord ns 64)))

(def sequences {:song-1 [[60 50] [96 30] [76 50]
                         [62 50] [90 50] [72 50]
                         [64 50] [] [74 50]
                         [66 50] [] ["fn" "song-2"]]

                :song-2 [[67 50 50 40 47 50 71 30] [] []
                         [64 50 33 40 49 50 71 30] [] []
                         [63 50 30 40 51 50 73 30] [] []
                         [62 50 40 40 63 50 74 30] [] [90 60 95 60 "fn" "song-1"]]

                :song-3 (map (fn [n] [;; (+ 60 (* 2 n)) 65 
                                      (+ 64 (* 1 n)) 65
                                      (- 59 (* 4 n)) 65]) (range 12))

                :song-4 [[60 50] [] [] [] [62 50] [64 50] [] [] [] [] [] [66 50]]

;              :song-5 [[] [] [] [90 10 101 5] [] [] [] [] [30 10] (chord [60 64 67 71]) [] ["fn" "song-6"]]
 ;             :song-6 [(chord [64 68 73]) (chord (map #(+ 2 %) [64 68 73])) [] [] [] [] [] [] [] [] [] ["fn" "song-7"]]
  ;            :song-7 [[69 50] [] [] [] [] [] [69 10] [] [] [] [] ["fn" "song-8"]]
   ;           :song-8 [(chord [56 59 63 67]) [] [] [] [] [] [59 10] [] [] [] [] ["fn" "song-5"]]

;              :song-5 [[60 40] [] [] [] [67 40] [] [] [] [65 30 58 10] [] [] [] (chord [67 71 75 79]) [] [] ["fn" "song-6"]]
;              :song-6 [[] [] [] [] [] [] [] [] (chord [46]) [] [] [] [] [] [] ["fn" "song-7"]]
;              :song-7 [(chord [60 65 68 71]) [] [] [] [] [] [] [] [] [] [] [] [] [] [] ["fn" "song-8"]]
;              :song-8 [(chord [55 67 70 74]) [] [] [] [] [] [] [] [] [] [] [] [] [] [] ["fn" "song-5"]]

                :song-5 [[60 40] [] [] [] [67 40] [] [] [] [65 30 58 10] [] [] [] (chord [67 71 75 79]) [] [] ["fn" "song-6"]]
                :song-6 [[60 40] [] [] [] [67 40] [] [] [] [65 30 58 10] [] [] [] (chord [67 71 75 79]) [] [] ["fn" "song-7"]]
                :song-7 [(chord [60 65 68 71]) [] [] [] [] [] [] [] [] [] [] [] [] [] [] ["fn" "song-8"]]
                :song-8 [(chord [55 67 70 74]) [] [] [] [] [] [] [] [] [] [] [] [] [] [] ["fn" "song-5"]]})

(defn send-seq
  "sends a sequence of beats. if s is a keyword, lookup in sequences"
  [s]
  (doall
   (map send-beat
        (map #(+ 1 %) (range))
        (if (keyword? s)
          (sequences s)
          s))))

(defn merge-seqs
  "merges the beats of each sequence, using the first sequence's length"
  [& seqs]
  (reduce (fn [acc sequence] (map-indexed (fn [i beat] (concat beat  (nth sequence i []))) acc))
          seqs))

(defn rotate-seq
  "rotates sequence by n"
  [s n]
  (map-indexed
   (fn [i beat] (nth s
                     (mod (+ i n) (count s))))
   s))

(defn repeat-flat [n coll] (flatten (repeat n coll)))

(defn map-if-num [fn coll]
  (map #(if (number? %) (fn %) %)
       coll))

(comment "how to use send-seq"

         (send-seq
          (with-vel (map #(+ 60 (* 2 %)) (range 12)) 20))

         (send-seq (with-vel [40 :r :r
                              40 :r 40
                              40 :r :r
                              40 :r 40]))

         (send-seq
          (merge-seqs

           (with-vel (repeat 32 []))

           (with-vel (rotate-seq (map #(+ 32 (* 5 %)) (range 12)) 2) 1)

           (with-vel (repeat-flat 8 [30 :r :r]) 5) ; four on floor

           ;; (with-vel (repeat-flat 2 [:r :r :r 78 :r :r]) 10) ; 2 and 4

           (with-vel (map-if-num #(+ 38 %) [40 :r :r
                                            40 :r 40
                                            40 :r :r
                                            40 :r 40]) 10) ; jazz ride
           (with-vel
             (rotate-seq
              (repeat-flat 3 (map #(if (number? %) (+ 66 %) %)
                                  [0 :r 0
                                   :r 0 0
                                   :r 0 :r
                                   0 :r 0])) 6)
             5) ; bembe wheel

           (with-vel
             (rotate-seq (map-if-num
                          #(- % 20)
                          (identity [66 66 66 :r 56 60 66 :r 66 67 66 :r
                                     :r :r :r 54 :r :r :r :r 69 67 66 56])) 10)
             1)) ; snare ostenato
          )

; number 2
         (send-seq
          (merge-seqs

           (with-vel (rotate-seq (map #(+ 66 (* 4 %)) (range 12)) 2) 0)

           (with-vel (repeat-flat 4 [60 :r :r]) 0) ; four on floor

           (with-vel (repeat-flat 2 [:r :r :r 77 :r :r]) 0) ; 2 and 4

           (with-vel [40 :r :r
                      40 :r 40
                      40 :r :r
                      40 :r 40] 0) ; jazz ride
           (with-vel
             (rotate-seq
              [47 :r 47
               :r 47 47
               :r 47 :r
               47 :r 47] 0)
             0) ; bembe wheel

           (with-vel
             (rotate-seq [66 66 66 :r 66 66 66 :r 69 67 66 :r] 0)
             0)) ; snare ostenato
          )

         (send-beat 12
                    ["fn"
                     (str '#(send-beat 11 [90 20]))])

         ((eval (read-string (str '#(send-beat 11 [80 20])))))

         (send-seq (with-vel [40 :r :r
                              40 :r 40
                              40 :r :r
                              40 :r 40])))

(def fns {:fn1 #()})

(defn handle-fn [osc-msg]
  (let [msg (first (:args osc-msg))
        fn-keyword (keyword msg)]
    (if (contains? fns fn-keyword)
      (eval (fns fn-keyword))
      (do ; TODO figure out how to literal
;        ((eval (read-string msg)))
;        (println (eval (read-string msg)))
        ))
    nil))

(osc-handle server "/fn" #'handle-fn)
